#!/usr/bin/env node

'use strict';

const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');
const ora = require('ora');

const yargs = require('yargs')
  .usage('Usage: $0 [COMMAND] [OPTIONS]')
  .example('$0 generate -o /my/csar-dir', 'Generate CSAR')

  .command('generate', 'Generate TOSCA CSAR')
  .command('g', 'Alias for generate')
  .command('merge', 'Merge CSAR specs')
  .command('m', 'Alias for merge')
  .demand(1, 'Valid command required')
  //.string('_')

  //.describe('debug', 'Debug mode, print error stacktrace')
  .boolean('debug')
  .global('debug'),

  argv = yargs.argv,
  command = _.first(argv._);

const exit = (err, out) => {
  if (err && argv.debug) {
    throw err;
  } else if (err) {
    console.log(err.toString());
    process.exit(1);
  } else {
    if (out) console.log(out);
    process.exit();
  }
};



if (_.includes(['generate', 'g'], command)) {
  const argvGen = yargs.reset()
    .usage('Usage: $0 generate | g [OPTIONS]') // PATH | URL | -
    .example('$0 generate -o /my/csar-dir', 'Generate CSAR as directory')
    .example('$0 g -p -o /my/csar.zip', 'Generate CSAR as ZIP file')

    .help('h')
    .alias('h', 'help')

    .string('s')
    .describe('s', 'Path to CSAR spec')
    .alias('s', 'spec')
    .normalize('s')
    .nargs('s', 1)

    .string('c')
    .describe('c', 'Path to working dir used as context')
    .alias('c', 'context')
    .normalize('c')
    .nargs('c', 1)
    //.default('c', process.cwd())

    .string('o')
    .describe('o', 'Path to output dir or file; use - for stdout')
    .alias('o', 'output')
    .normalize('o')
    .nargs('o', 1)
    //.demand(['output'])

    .boolean('p')
    .describe('p', 'Package generated CSAR as single file')
    .alias('p', 'pack')

    .string('pack-format')
    .describe('pack-format', 'Packaging format of generated CSAR')
    .choices('pack-format', ['zip', 'tar', 'tgz'])
    .default('pack-format', 'zip')
    .nargs('pack-format', 1)

    .boolean('camelize')
    .describe('camelize', 'Convert names to camelCase')

    .boolean('clear-output')
    .describe('clear-output', 'Remove existing output dir or file')

    .argv;
 
  argvGen.context = argvGen.context || process.cwd();
  argvGen.spec = argvGen.spec || path.join(argvGen.context, 'csarspec.json');
  argvGen.spec = path.resolve(argvGen.spec);

  let csarSpec;

  try {
    csarSpec = fs.readFileSync(argvGen.spec, 'utf8');
  } catch (err) {
    argvGen.spec = path.join(argvGen.spec, 'csarspec.json');

    try {
      csarSpec = fs.readFileSync(argvGen.spec, 'utf8');
    } catch (err2) {
      exit(new Error('cannot find or read csarspec.json, please specify location'));
    }
  }

  if (argvGen.output && argvGen.clearOutput) fs.removeSync(argvGen.output);

  //TODO support reading csarSpec from stdin instead of argvGen.spec, check https://www.npmjs.com/package/get-stdin
  // ... by default set context/workingDir=EMPTY_TEMP_DIR if csarspec is provided through stdin

  if (argvGen.output === '-') {
    const GenPacker = require('../lib/GenPacker');

    GenPacker().genpack(csarSpec, {
      workingDir: argvGen.context,
      outputStream: process.stdout,
      camelize: argvGen.camelize,
      format: argvGen.packFormat
    }, exit);
  } else if (argvGen.pack) {
    const GenPacker = require('../lib/GenPacker');

    const spinner = ora('Generating CSAR as packaged file').start();

    GenPacker().genpack(csarSpec, {
      workingDir: argvGen.context,
      outputFile: argvGen.output,
      camelize: argvGen.camelize,
      format: argvGen.packFormat
    }, (err, outputFile) => {
      spinner.clear();
      exit(err, outputFile);
    });
  } else {
    const Generator = require('../lib/Generator');

    const spinner = ora('Generating CSAR as directory').start();

    //setTimeout(() => {
    //  spinner.color = 'yellow';
    //  spinner.text = 'Loading rainbows';
    //}, 1000 * 1);

    Generator().generate(csarSpec, {
      workingDir: argvGen.context,
      outputDir: argvGen.output,
      camelize: argvGen.camelize
    }, (err, outputDir) => {
      spinner.clear();
      exit(err, outputDir);
    });
  }
} else if (_.includes(['merge', 'm'], command)) {
  exit(new Error('not implemented'));
} else {
  yargs.showHelp();
}
