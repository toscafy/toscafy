#!/usr/bin/env node

'use strict';

const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');
const ora = require('ora');
const getStdin = require('get-stdin');

const toscafyBin = process.env.TOSCAFY_BIN || 'toscafy' || '$0';

const yargs = require('yargs')
  .usage(`Usage: ${toscafyBin} [COMMAND] [OPTIONS]`)
  .example(`${toscafyBin} generate -o /my/csar-dir`, 'Generate CSAR')

  .command('generate', 'Generate TOSCA CSAR')
  .command('build', 'Alias for generate')
  .command('merge', 'Merge CSAR specs')
  .demand(1, 'Valid command required')
  //.string('_')

  //.describe('debug', 'Debug mode, print error stacktrace')
  .boolean('debug')
  .global('debug'),

  argv = yargs.argv,
  command = _.first(argv._);

const exit = (err, out) => {
  if (err && argv.debug) {
    console.log(err.toString());
    throw err;
  } else if (err) {
    console.log(err.toString());
    process.exit(1);
  } else if (out) {
    console.log(out);
  }

  process.exit();
};



if (_.includes(['generate', 'build'], command)) {
  const argvGen = yargs.reset()
    .usage(`Usage: ${toscafyBin} ${command} [OPTIONS]`) // PATH | URL | -
    .example(`${toscafyBin} ${command} -o /my/csar-dir`)
    .example(`${toscafyBin} ${command} -p -o /my/csar.zip`)

    .help('h')
    .alias('h', 'help')

    .string('s')
    .describe('s', 'Path to CSAR spec, use - for stdin')
    .alias('s', 'spec')
    .normalize('s')
    .nargs('s', 1)

    .string('c')
    .describe('c', 'Path to working dir used as context')
    .alias('c', 'context')
    .normalize('c')
    .nargs('c', 1)
    //.default('c', process.cwd())

    .string('o')
    .describe('o', 'Path to output dir or file, use - for stdout')
    .alias('o', 'output')
    .normalize('o')
    .nargs('o', 1)
    //.demand(['output'])

    .boolean('p')
    .describe('p', 'Package generated CSAR as single file')
    .alias('p', 'pack')

    .string('pack-format')
    .describe('pack-format', 'Packaging format of generated CSAR')
    .choices('pack-format', ['zip', 'tar', 'tgz'])
    .default('pack-format', 'zip')
    .nargs('pack-format', 1)

    .boolean('camelize')
    .describe('camelize', 'Convert names to camelCase')

    .boolean('clear-output')
    .describe('clear-output', 'Remove existing output dir or file')

    .argv;

  const generate = (csarSpec) => {
    if (argvGen.output && argvGen.clearOutput) fs.removeSync(argvGen.output);

    if (argvGen.output === '-') {
      const GenPacker = require('../lib/GenPacker');

      GenPacker().genpack(csarSpec, {
        workingDir: argvGen.context,
        outputStream: process.stdout,
        camelize: argvGen.camelize,
        format: argvGen.packFormat
      }, exit);
    } else if (argvGen.pack) {
      const GenPacker = require('../lib/GenPacker');

      const spinner = ora('Generating CSAR as packaged file').start();

      GenPacker().genpack(csarSpec, {
        workingDir: argvGen.context,
        outputFile: argvGen.output,
        camelize: argvGen.camelize,
        format: argvGen.packFormat
      }, (err, outputFile) => {
        spinner.clear();
        exit(err, outputFile);
      });
    } else {
      const Generator = require('../lib/Generator');

      const spinner = ora('Generating CSAR as directory').start();

      //setTimeout(() => {
      //  spinner.color = 'yellow';
      //  spinner.text = 'Loading rainbows';
      //}, 1000 * 1);

      Generator().generate(csarSpec, {
        workingDir: argvGen.context,
        outputDir: argvGen.output,
        camelize: argvGen.camelize
      }, (err, outputDir) => {
        spinner.clear();
        exit(err, outputDir);
      });
    }
  };

  argvGen.context = argvGen.context || process.cwd();

  if (argvGen.spec === '-') {
    getStdin().then(stdin => {
      try {
        const csarSpec = JSON.parse(stdin);

        generate(csarSpec);
      } catch (err) {
        exit(new Error('cannot parse stdin as JSON, ' + err));
      }
    }).catch(err => {
      exit(new Error('cannot parse stdin as JSON, ' + err));
    });
  } else {
    argvGen.spec = argvGen.spec || path.join(argvGen.context, 'csarspec.json');
    argvGen.spec = path.resolve(argvGen.spec);

    let csarSpec;

    try {
      csarSpec = fs.readFileSync(argvGen.spec, 'utf8');
    } catch (err) {
      argvGen.spec = path.join(argvGen.spec, 'csarspec.json');

      try {
        csarSpec = fs.readFileSync(argvGen.spec, 'utf8');
      } catch (err2) {
        return exit(new Error('cannot find or read csarspec.json, please specify location'));
      }
    }

    generate(csarSpec);
  }
} else if (_.includes(['merge'], command)) {
  exit(new Error('not implemented'));
} else {
  yargs.showHelp();
}
